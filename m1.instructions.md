# M1 Implementation Playbook

## 1. Prerequisites (contracts & environment)
- Ensure Foundry prereqs are ready: `cd contracts && cp env.example .env`, fill `RPC_URL`, `PRIVATE_KEY`, `ETHERSCAN_API_KEY`, then run `forge install`.
- Deploy the sandbox stack if artifacts are missing or stale:
  - `forge script script/DeployTokens.s.sol --rpc-url $RPC_URL --broadcast --verify`
  - `forge script script/DeployAggregator.s.sol --rpc-url $RPC_URL --broadcast --verify`
  - `forge script script/DeployOracle.s.sol --rpc-url $RPC_URL --broadcast --verify`
  - `forge script script/CreateMarket.s.sol --rpc-url $RPC_URL --broadcast --verify`
  - `forge script script/InitializeUtilization.s.sol --rpc-url $RPC_URL --broadcast`
  - Rerun `./update-env-from-artifacts.sh` (or the ops extraction helper) after each step so address JSON stays in sync for the frontend loader.
- Deploy the MetaMorpho v1.1 vault that Page 1 targets:
  - If no script exists yet, author a short Forge script (or use viem/TypeScript) that calls the MetaMorpho factory (`0x98CbFE4053ad6778E0E3435943aC821f565D0b03`) with the planned params (`timelock = 0`, human-readable name/symbol, the deployed fakeUSD asset, curator/guardian/allocator addresses).
  - Record the vault deployment in `contracts/broadcast` (or another deterministic location) so the frontend can import the address; persist any role-assignment tx hashes as well.
  - Assign roles (owner/curator/allocator/guardian) and enable at least the sandbox market with a small supply cap; make sure withdraw queue contains an idle slot so Page 1 can demonstrate liquidity states.
- Seed the vault with a small initial deposit (e.g. 1 fakeUSD from deployer) to avoid zero-share edge cases when computing share price/APY.
- Sync the shared config: run the ops helper (`cd ops && npm install && npm run ops:extract:addresses`) if needed so `frontend/src/lib/contracts.ts` can discover all artifacts; fall back to exporting overrides via `.env.local` if the broadcast files are absent.
- Prepare the frontend workspace: `cd frontend`, `cp .env.local.example .env.local`, set `NEXT_PUBLIC_RPC_URL` if required, then `npm install`.

## 2. Frontend foundations
- Extend the shared contract loader (`frontend/src/lib/contracts.ts`) so it exposes a `vaults.metaMorphoDemo` entry that pulls the deployed vault address (prefer broadcast artifacts, with an env override fallback). Expose helper getters for `asset`, `vaultAddress`, and queue-related metadata.
- Reuse the official ABIs shipped in `@morpho-org/blue-sdk-viem` instead of hand-maintaining JSON:
  - Import `metaMorphoAbi`, `blueAbi`, and any other surfaces from `@morpho-org/blue-sdk-viem` (`frontend/src/lib/abis.ts` already demonstrates this pattern for Blue and IRM).
  - When you need additional selectors (e.g. permissioned actions), consult the library’s `lib/abis.d.ts` and `MetaMorphoAction.d.ts` rather than expanding manual ABI arrays.
- Introduce a new route (e.g. `/vaults`) under `frontend/src/app/` that sits alongside `/setup`; update `frontend/src/components/Navigation.tsx` so the link appears once the wallet is connected.

## 3. Data hooks & state
- Prefer the high-level fetchers from `@morpho-org/blue-sdk-viem/lib/fetch/*` to hydrate vault data:
  - Use `fetchVault`, `fetchAccrualVault`, and `fetchVaultConfig` to grab metadata, asset, fee, queue lengths, and allocations in a single viem client call.
  - Use `fetchVaultUser` for user share/asset balances and limits; pair with `fetchVaultMarkets` / `fetchVaultMarketConfig` for per-market allocation data when building the breakdown.
  - When working inside React hooks, wrap these helpers in `useQuery`/`useSuspenseQuery` and share the same viem client Wagmi already provides.
- For allocation insights, supplement the SDK responses with direct `morpho.market(id)` reads (still using `blueAbi`) only when the fetch convenience layer does not expose a field. The SDK returns strongly-typed market params and totals you can reuse for percentages.
- Track share price snapshots locally (React Query cache or component state) so the UI can compute realized APY over time as recommended in `plan.md` (share price delta sampling). If history is empty, fall back to the weighted underlying supply APY returned by `fetchAccrualVault`.
- Surface guard-rail states from the docs/plan: detect cap exhaustion (`maxDeposit == 0` from `fetchVaultUser`), limited liquidity (`maxWithdraw`), or multi-hop withdraw queue (`withdrawQueueLength > 1`), and expose flags for the UI to react.

## 4. UI composition
- Scaffold `frontend/src/components/vaults/` with modular cards:
  - **Overview card**: name, symbol, asset, total assets, total supply, share price, fees, governance roles, timelock status.
  - **Performance card**: realized APY, share price chartlet (simple sparkline), last accrual timestamp, plan-provided timing tips.
  - **Allocation card**: table of supply/withdraw queues (market symbol, utilization, LLTV, queue position) with guidance on reallocation effects.
  - **Actions card**: deposit/withdraw/redeem forms, displaying preview outputs and queue/liquidity warnings inline.
- Gate the page behind wallet connection using the existing Wagmi provider (`useAccount`). When disconnected, show a call-to-action rather than empty metrics.
- Format numerical displays with 6–8 decimal precision so small share-price movements remain visible, reflecting the hackathon observability goals in `plan.md`.

## 5. Transaction flows
- Implement deposit flow:
  - Fetch and enforce `maxDeposit` (available via `fetchVaultUser`).
  - Ensure ERC20 allowance via `approve` before calling `deposit(assets, receiver)`; reuse toasts/status notifications for UX feedback.
  - After success, invalidate vault & token queries so balances refresh instantly.
- Implement withdraw (`withdraw(assets, receiver, owner)`) and redeem (`redeem(shares, receiver, owner)`) flows:
  - Use `previewWithdraw` / `previewRedeem` values (available on the ABI and via SDK helpers) to show expected outputs and slippage notes.
  - Block submission when `maxWithdraw` / `maxRedeem` constraints fail and include contextual messaging (e.g., “cap reached”, “queued withdrawal likely”).
  - Handle failures cleanly (paused vault, insufficient idle liquidity) and surface hints drawn from the plan’s UX guidance.
- Optional: use `MetaMorphoAction` helpers from the SDK when encoding admin operations or scripted demos (e.g., setting allocators or queues) to avoid manual encoding; expose a lightweight transaction history panel for end users if bandwidth allows.

## 6. Status, risk & education overlays
- Present governance info (owner, curator, guardian, allocator) and pending timelock/guardian changes so users understand operational controls.
- Add a “What moves APY” callout describing the timing expectations table from `plan.md` (deposits immediate, accrual 10–30 min, borrower bot cycle ≈ 30 min) to set expectations during demos.
- Highlight queue semantics: badge the first withdraw queue entry as “instant”, subsequent ones as “queued”, and note that allocator actions affect ordering.

## 7. Validation & handoff
- Run `npm run lint` and `npm run dev` in `frontend/`; manually test deposits and withdrawals end-to-end on Sepolia using the deployed fakeUSD asset.
- Confirm that metrics update after allocator/intervention (e.g., run `InitializeUtilizationImproved.s.sol` or a borrower bot) to validate the APY polling logic.
- Update `frontend/README.md` with any new env vars or runbook notes, and capture follow-up items for M2 (ops scripts, multi-market support) once Page 1 ships.
